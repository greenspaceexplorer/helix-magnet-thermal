	PROGRAM TEST
	IMPLICIT NONE
	INTEGER :: I !WILL NEED ONE ITERABLE VARIABLE FOR EACH INPUT PARAMETER
	INTEGER :: NUMROWS,NUMCOLS,NUMLINES,NUMPARAM
	PARAMETER (NUMPARAM = 1) !NUMBER OF INPUT PARAMETERS
	INTEGER :: MAXITER(NUMPARAM)
	REAL :: PARAM(NUMPARAM),DELPARAM(NUMPARAM) !PLACE CHI2 INPUT PARAMETERS IN HERE - CHANGE NUMPARAM AS NEEDED
	REAL, ALLOCATABLE :: BDATA(:,:) 
	REAL CHI2, MINCHI2
	REAL PI
	REAL X(3)
	CHARACTER(LEN=100) :: FILENAME
	
C	COMMON/BARRAYDATA/BDATA

	PI = 4.D0*DATAN(1.D0)

C	GET DATA FROM FILE
	FILENAME = 'helixdata.txt'
	NUMCOLS = 7
	NUMROWS = NUMLINES(FILENAME)
C	PRINT *,"Number of lines = ",NUMROWS
	ALLOCATE (BDATA(NUMROWS,NUMCOLS))
	CALL SETARRAY(FILENAME,BDATA,NUMROWS,NUMCOLS)
C	CALL PRINTMATRIX(BDATA,NUMROWS,NUMCOLS)
	
	PARAM = 0.D0 !INITIALIZE ALL INPUT PARAMETERS TO ZERO FOR NOW
	DELPARAM(1) = 2.D0*PI/360.D0 !INITIALIZE ROTATION STEP TO 1 DEGREE
	MAXITER(1) = 360 !ITERATE ROTATIONS OVER 360 DEGREES
	
	!REMEMBER, YOU WILL NEED TO HAVE A NESTED LOOP FOR EACH ADDITIONAL PARAMETER THAT YOU ADD
	!I HAVE COMMENTED IN AN EXAMPLE TO SHOW WHAT I MEAN IF YOU ADDED A SECOND PARAMETER
	DO I = 1,MAXITER(1)
C		DO J = 1,MAXITER(2) !EXAMPLE 
			CALL CHISQ(BDATA,NUMROWS,NUMCOLS,CHI2,PARAM,NUMPARAM)
			IF (CHI2.LT.MINCHI2) MINCHI2 = CHI2
			PARAM(1) = PARAM(1) + DELPARAM(1) !ADVANCE PARAMETER BY ONE INCREMENT
C		ENDDO
C		PARAM(2) = PARAM(2) + DELPARAM(2)
	ENDDO
	
	PRINT *, "MINIMUM CHI2 = ", CHI2
	PRINT *, "Z ROTATION = ", PARAM(1)
	STOP
	END PROGRAM TEST

C	***************************************************************************
C 	CALCULATE CHI SQUARED
C	***************************************************************************
	
	SUBROUTINE CHISQ(BDATA,NUMROWS,NUMCOLS,CHI2,PARAM,NPARAM)
	IMPLICIT NONE
	INTEGER :: I,J,N
	PARAMETER (N=3)
	INTEGER :: NUMROWS, NUMCOLS, NPARAM
	REAL :: CHI2,DELCHI2,R,HOLD
	REAL :: X0(N),XF(N),B0(N),BF(N),ERR0(N)
	REAL :: PARAM(NPARAM)
	REAL :: BDATA(NUMROWS,NUMCOLS)
	EXTERNAL HEAT_MAG
	
C	INITIALIZE CHI2 TO ZERO
	CHI2 = 0.0
	
C	ASSIGN VALUES FROM DATA ARRAY FOR EASY CHI2 EQUATION
	DO I = 1, NUMROWS
		DO J = 1, N
			X0(J) = BDATA(I,J)
			B0(J) = BDATA(I,J+3)
C			SET ERROR OF B-FIELD TO 5%	
			ERR0(J) = 0.05*BDATA(I,J+3)
		ENDDO
		
C		CHANGING COORDINATES TO PROPER ORIGIN AND UNITS?
		X0(1) = (X0(1)-6)*3.016
		X0(2) = (X0(2)-6)*3.016
		X0(3) = (X0(3)-6)*3.016
		
		CALL ROTATE_Z(X0,XF,N,PARAM(1))
		
		R = 0.D0
		DO J = 1, N
			R = R + XF(J)**2		
		ENDDO
		R = SQRT(R)
		CALL HEAT_MAG(XF(1),XF(2),XF(3),BF(1),BF(2),BF(3))
		
C		CONVERT B-FIELD TO CARTESIAN COORDINATES	
		IF (R.NE.0.D0) THEN
			HOLD = BF(2)
			BF(2) = BF(1)*XF(2)/R
			BF(3) = BF(1)*XF(3)/R
			BF(1) = HOLD
		ELSE
			HOLD = BF(2)
			BF(2) = BF(1)
			BF(3) = BF(1)
			BF(1) = HOLD
		ENDIF

C		CALCULATE CHI2	
		DO J = 1, N
			CHI2 = CHI2 + ((B0(J)-BF(J))/ERR0(J))**2
		ENDDO
	ENDDO
	
	RETURN
	END SUBROUTINE CHISQ

C	***************************************************************************
C 	CALCULATE ROTATION ABOUT Z-AXIS
C	***************************************************************************
	
	SUBROUTINE ROTATE_Z(X0, XF, N, T)
	IMPLICIT NONE
	INTEGER :: I,J,N
	REAL :: T
	REAL :: X0(N),XF(N)
	REAL :: ROTATION (N,N)
	
	IF (N.NE.3) THEN
		PRINT *, "ERROR: INVALID NUMBER OF COORDINATES"
		STOP 1
	ENDIF
	
	XF = 0.D0
C	DEFINE AN ARRAY FOR COORDIANTE ROTATION 
C	ROTATION MATRIX EQUATION (3.35) ARFKIN 7TH ED 
	ROTATION(1,1)=COS(T)
	ROTATION(1,2)=SIN(T)
	ROTATION(1,3)=0
	ROTATION(2,1)=-SIN(T)
	ROTATION(2,2)=COS(T)
	ROTATION(2,3)=0
	ROTATION(3,1)=0
	ROTATION(3,2)=0
	ROTATION(3,3)=1 

	
	DO I=1, N  !MULTIPLY THE ROTATION MATRIX BY THE VECTOR
		DO J = 1, N
			XF(I) = XF(I) + ROTATION(I,J)*X0(J)
		ENDDO
	ENDDO
	RETURN  
	END SUBROUTINE ROTATE_Z
	
C	***************************************************************************
C 	SET ARRAY IN COMMON BLOCK
C	***************************************************************************

	SUBROUTINE SETARRAY(FILENAME,BDATA,NUMROWS,NUMCOLS)
	IMPLICIT NONE
	INTEGER :: NUMROWS,NUMCOLS,I,J
	REAL :: BDATA(NUMROWS,NUMCOLS)
	CHARACTER (LEN=100) :: FILENAME
	
C	COMMON/BARRAYDATA/BDATA
	
	OPEN (10, FILE=FILENAME)
	READ(10,*) ((BDATA(I,J),J=1,NUMCOLS),I=1,NUMROWS)
	CLOSE(10)
	
	END SUBROUTINE SETARRAY

C	***************************************************************************
C 	PRINT A MATRIX
C	***************************************************************************
	
	SUBROUTINE PRINTMATRIX(ARRAY, N, M)
	IMPLICIT NONE
	INTEGER :: N,M,I
	REAL :: ARRAY(N,M)
	DO I = 1,N
		PRINT*, ARRAY(I,:)
	END DO
	END SUBROUTINE PRINTMATRIX
	
C	***************************************************************************
C 	FIND NUMBER OF ROWS IN A FILE
C	***************************************************************************
	
	FUNCTION NUMLINES(FILENAME)
	CHARACTER(LEN=100) :: FILENAME
	INTEGER :: NUMLINES,IOS
	NUMLINES = 0
	OPEN (10, FILE=FILENAME)
	DO
		READ (10,*,IOSTAT=IOS)
		IF (IOS.NE.0) EXIT
		NUMLINES = NUMLINES + 1
	ENDDO
	CLOSE(10)
	END FUNCTION NUMLINES
